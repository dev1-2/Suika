<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Suika Game - Comic Style</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }

        .game-area {
            position: relative;
            background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
            border: 8px solid #333;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3), inset 0 0 20px rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }

        canvas {
            display: block;
            cursor: crosshair;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%);
        }

        .side-panel {
            background: white;
            border: 8px solid #333;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            min-width: 250px;
        }

        .side-panel h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 24px;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.1);
        }

        .score-display {
            font-size: 32px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.1);
        }

        .best-score {
            font-size: 14px;
            color: #666;
            margin-bottom: 20px;
        }

        .next-fruit {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 3px solid #333;
        }

        .next-fruit h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .fruit-preview {
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .fruit-preview canvas {
            border: 2px solid #333;
            border-radius: 10px;
            background: white;
        }

        .controls {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 10px;
            border: 3px solid #333;
            margin-bottom: 20px;
        }

        .controls h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .controls p {
            font-size: 12px;
            color: #666;
            margin: 5px 0;
        }

        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: 3px solid #333;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            border-radius: 15px;
        }

        .game-over-screen.show {
            display: flex;
        }

        .game-over-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            border: 8px solid #333;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        }

        .game-over-content h1 {
            font-size: 48px;
            color: #e74c3c;
            margin-bottom: 20px;
            text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.2);
        }

        .game-over-content p {
            font-size: 24px;
            color: #333;
            margin-bottom: 30px;
        }

        .game-over-content button {
            width: 200px;
            font-size: 18px;
            padding: 15px;
        }

        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
            }

            .side-panel {
                min-width: 100%;
            }

            .score-display {
                font-size: 28px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
            <div class="game-over-screen" id="gameOverScreen">
                <div class="game-over-content">
                    <h1>GAME OVER!</h1>
                    <p id="finalScore">Final Score: 0</p>
                    <button onclick="location.reload()">Play Again</button>
                </div>
            </div>
        </div>

        <div class="side-panel">
            <h2>üçâ SUIKA</h2>
            
            <div>
                <div class="score-display" id="scoreDisplay">0</div>
                <div class="best-score">
                    Best Score: <span id="bestScore">0</span>
                </div>
            </div>

            <div class="next-fruit">
                <h3>NEXT FRUIT</h3>
                <div class="fruit-preview">
                    <canvas id="previewCanvas" width="60" height="60"></canvas>
                </div>
            </div>

            <div class="controls">
                <h3>CONTROLS</h3>
                <p>üñ±Ô∏è <strong>Mouse:</strong> Move & Click to drop</p>
                <p>üì± <strong>Touch:</strong> Tap to drop</p>
                <p><strong>Space:</strong> Drop fruit</p>
            </div>

            <button onclick="resetGame()">New Game</button>
            <button onclick="togglePause()" id="pauseBtn">Pause</button>
        </div>
    </div>

    <script>
        // Game Configuration
        const GRAVITY = 0.5;
        const RESTITUTION = 0.7;
        const FRICTION = 0.99;
        const CANVAS_WIDTH = 400;
        const CANVAS_HEIGHT = 600;
        const CONTAINER_MARGIN = 20;

        // Fruit Types (10 types with increasing sizes and values)
        const FRUIT_TYPES = [
            { id: 0, name: 'Cherry', size: 15, value: 1, color: '#e74c3c', emoji: 'üçí' },
            { id: 1, name: 'Strawberry', size: 18, value: 3, color: '#c0392b', emoji: 'üçì' },
            { id: 2, name: 'Orange', size: 22, value: 6, color: '#f39c12', emoji: 'üçä' },
            { id: 3, name: 'Lemon', size: 25, value: 10, color: '#f1c40f', emoji: 'üçã' },
            { id: 4, name: 'Peach', size: 28, value: 15, color: '#f8a07a', emoji: 'üçë' },
            { id: 5, name: 'Pineapple', size: 32, value: 21, color: '#f4d03f', emoji: 'üçç' },
            { id: 6, name: 'Grape', size: 36, value: 28, color: '#8e44ad', emoji: 'üçá' },
            { id: 7, name: 'Watermelon', size: 42, value: 36, color: '#2ecc71', emoji: 'üçâ' },
            { id: 8, name: 'Melon', size: 48, value: 45, color: '#1abc9c', emoji: 'üçà' },
            { id: 9, name: 'Pumpkin', size: 55, value: 55, color: '#e67e22', emoji: 'üéÉ' }
        ];

        // Canvas Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');

        // Game State
        let gameState = {
            fruits: [],
            score: 0,
            bestScore: localStorage.getItem('suikaBestScore') || 0,
            nextFruitId: getRandomFruitId(),
            gameOver: false,
            paused: false,
            mouseX: CANVAS_WIDTH / 2,
            mouseY: 50,
            mouseDown: false,
            activeFruit: null,
            nextSpawnTime: 0
        };

        // Initialize Canvas Size
        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth - 300, 400);
            const maxHeight = window.innerHeight - 40;
            const aspectRatio = CANVAS_WIDTH / CANVAS_HEIGHT;
            
            let width = maxWidth;
            let height = width / aspectRatio;
            
            if (height > maxHeight) {
                height = maxHeight;
                width = height * aspectRatio;
            }
            
            canvas.width = width;
            canvas.height = height;
            
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Fruit Class
        class Fruit {
            constructor(type, x, y) {
                this.type = FRUIT_TYPES[type];
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationVelocity = (Math.random() - 0.5) * 0.1;
                this.merged = false;
            }

            update() {
                // Apply gravity
                this.vy += GRAVITY;
                
                // Apply velocity
                this.x += this.vx;
                this.y += this.vy;
                
                // Apply friction
                this.vx *= FRICTION;
                this.vy *= FRICTION;
                
                // Update rotation
                this.rotation += this.rotationVelocity;
                
                // Boundary collisions
                const radius = this.type.size;
                
                // Left/Right boundaries
                if (this.x - radius < CONTAINER_MARGIN) {
                    this.x = CONTAINER_MARGIN + radius;
                    this.vx *= -RESTITUTION;
                    this.rotationVelocity *= -1;
                } else if (this.x + radius > canvas.width - CONTAINER_MARGIN) {
                    this.x = canvas.width - CONTAINER_MARGIN - radius;
                    this.vx *= -RESTITUTION;
                    this.rotationVelocity *= -1;
                }
                
                // Bottom boundary
                if (this.y + radius > canvas.height - CONTAINER_MARGIN) {
                    this.y = canvas.height - CONTAINER_MARGIN - radius;
                    this.vy *= -RESTITUTION;
                }
                
                // Top boundary (game over detection)
                if (this.y - radius < CONTAINER_MARGIN) {
                    gameState.gameOver = true;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                const radius = this.type.size;
                
                // Draw radial gradient
                const gradient = ctx.createRadialGradient(-5, -5, 0, 0, 0, radius);
                gradient.addColorStop(0, this.lightenColor(this.type.color, 50));
                gradient.addColorStop(0.6, this.type.color);
                gradient.addColorStop(1, this.darkenColor(this.type.color, 30));
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw dark outline (comic style)
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = Math.max(2, radius / 10);
                ctx.stroke();
                
                // Draw shine effect
                const shineGradient = ctx.createRadialGradient(-radius * 0.3, -radius * 0.3, 0, 0, 0, radius * 0.6);
                shineGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                shineGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
                shineGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = shineGradient;
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw eyes on larger fruits
                if (this.type.size > 30) {
                    ctx.fillStyle = 'white';
                    const eyeSize = radius * 0.25;
                    const eyeDistance = radius * 0.4;
                    
                    // Left eye
                    ctx.beginPath();
                    ctx.arc(-eyeDistance, -radius * 0.2, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Right eye
                    ctx.beginPath();
                    ctx.arc(eyeDistance, -radius * 0.2, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Pupils
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.arc(-eyeDistance, -radius * 0.2, eyeSize * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(eyeDistance, -radius * 0.2, eyeSize * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }

            lightenColor(color, percent) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 +
                    (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255))
                    .toString(16).slice(1);
            }

            darkenColor(color, percent) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) - amt;
                const G = (num >> 8 & 0x00FF) - amt;
                const B = (num & 0x0000FF) - amt;
                return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 +
                    (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255))
                    .toString(16).slice(1);
            }

            getDistance(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            collidesWith(other) {
                return this.getDistance(other) < this.type.size + other.type.size;
            }
        }

        // Helper Functions
        function getRandomFruitId() {
            return Math.floor(Math.random() * Math.min(5, FRUIT_TYPES.length));
        }

        function drawNextFruitPreview() {
            previewCanvas.width = 60;
            previewCanvas.height = 60;
            previewCtx.clearRect(0, 0, 60, 60);
            
            const fruitType = FRUIT_TYPES[gameState.nextFruitId];
            const x = 30, y = 30;
            const radius = Math.min(25, fruitType.size);
            
            // Draw gradient
            const gradient = previewCtx.createRadialGradient(x - 5, y - 5, 0, x, y, radius);
            gradient.addColorStop(0, lightenColor(fruitType.color, 50));
            gradient.addColorStop(0.6, fruitType.color);
            gradient.addColorStop(1, darkenColor(fruitType.color, 30));
            
            previewCtx.fillStyle = gradient;
            previewCtx.beginPath();
            previewCtx.arc(x, y, radius, 0, Math.PI * 2);
            previewCtx.fill();
            
            previewCtx.strokeStyle = '#1a1a1a';
            previewCtx.lineWidth = 2;
            previewCtx.stroke();
        }

        function lightenColor(color, percent) {
            const num = parseInt(color.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, (num >> 8 & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            return "#" + (0x1000000 + R*0x10000 + G*0x100 + B).toString(16).slice(1);
        }

        function darkenColor(color, percent) {
            const num = parseInt(color.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, (num >> 16) - amt);
            const G = Math.max(0, (num >> 8 & 0x00FF) - amt);
            const B = Math.max(0, (num & 0x0000FF) - amt);
            return "#" + (0x1000000 + R*0x10000 + G*0x100 + B).toString(16).slice(1);
        }

        function spawnFruit() {
            if (gameState.activeFruit) return;
            
            const fruitId = gameState.nextFruitId;
            const fruit = new Fruit(fruitId, gameState.mouseX, CONTAINER_MARGIN + FRUIT_TYPES[fruitId].size);
            
            gameState.activeFruit = fruit;
            gameState.nextFruitId = getRandomFruitId();
            drawNextFruitPreview();
        }

        function handleCollisions() {
            for (let i = 0; i < gameState.fruits.length; i++) {
                for (let j = i + 1; j < gameState.fruits.length; j++) {
                    const fruitA = gameState.fruits[i];
                    const fruitB = gameState.fruits[j];
                    
                    if (fruitA.collidesWith(fruitB) && fruitA.type.id === fruitB.type.id) {
                        // Merge fruits
                        const newTypeId = fruitA.type.id + 1;
                        if (newTypeId < FRUIT_TYPES.length) {
                            const mergedX = (fruitA.x + fruitB.x) / 2;
                            const mergedY = (fruitA.y + fruitB.y) / 2;
                            const mergedFruit = new Fruit(newTypeId, mergedX, mergedY);
                            
                            // Average velocities
                            mergedFruit.vx = (fruitA.vx + fruitB.vx) / 2;
                            mergedFruit.vy = (fruitA.vy + fruitB.vy) / 2;
                            
                            gameState.fruits.splice(j, 1);
                            gameState.fruits[i] = mergedFruit;
                            gameState.score += FRUIT_TYPES[newTypeId].value;
                            updateScore();
                        }
                    }
                }
            }
        }

        function updateScore() {
            document.getElementById('scoreDisplay').textContent = gameState.score;
            if (gameState.score > gameState.bestScore) {
                gameState.bestScore = gameState.score;
                localStorage.setItem('suikaBestScore', gameState.bestScore);
                document.getElementById('bestScore').textContent = gameState.bestScore;
            }
        }

        function update() {
            if (gameState.paused || gameState.gameOver) return;
            
            // Update active fruit position with mouse
            if (gameState.activeFruit) {
                const maxX = canvas.width - CONTAINER_MARGIN - gameState.activeFruit.type.size;
                const minX = CONTAINER_MARGIN + gameState.activeFruit.type.size;
                gameState.activeFruit.x = Math.max(minX, Math.min(maxX, gameState.mouseX));
                gameState.activeFruit.y = CONTAINER_MARGIN + gameState.activeFruit.type.size;
            }
            
            // Update fruits
            for (let fruit of gameState.fruits) {
                fruit.update();
            }
            
            // Handle collisions
            handleCollisions();
            
            // Remove off-screen fruits (optional cleanup)
            gameState.fruits = gameState.fruits.filter(f => f.y < canvas.height + 100);
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw background gradient
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, '#87CEEB');
            bgGradient.addColorStop(1, '#E0F6FF');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw container border
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 4;
            ctx.strokeRect(CONTAINER_MARGIN, CONTAINER_MARGIN, 
                          canvas.width - CONTAINER_MARGIN * 2, 
                          canvas.height - CONTAINER_MARGIN * 2);
            
            // Draw fruits
            for (let fruit of gameState.fruits) {
                fruit.draw(ctx);
            }
            
            // Draw active fruit (being held)
            if (gameState.activeFruit) {
                gameState.activeFruit.draw(ctx);
            }
            
            // Draw next fruit indicator line
            if (gameState.activeFruit) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(gameState.mouseX, 0);
                ctx.lineTo(gameState.mouseX, gameState.activeFruit.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        function gameLoop() {
            update();
            draw();
            
            if (gameState.gameOver) {
                document.getElementById('finalScore').textContent = `Final Score: ${gameState.score}`;
                document.getElementById('gameOverScreen').classList.add('show');
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Event Listeners
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            gameState.mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
        });

        canvas.addEventListener('click', () => {
            if (!gameState.gameOver && !gameState.paused && !gameState.activeFruit) {
                spawnFruit();
            }
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            gameState.mouseX = (touch.clientX - rect.left) * (canvas.width / rect.width);
            if (!gameState.gameOver && !gameState.paused && !gameState.activeFruit) {
                spawnFruit();
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            gameState.mouseX = (touch.clientX - rect.left) * (canvas.width / rect.width);
        });

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (!gameState.gameOver && !gameState.paused && !gameState.activeFruit) {
                    spawnFruit();
                }
            }
        });

        function resetGame() {
            gameState = {
                fruits: [],
                score: 0,
                bestScore: gameState.bestScore,
                nextFruitId: getRandomFruitId(),
                gameOver: false,
                paused: false,
                mouseX: CANVAS_WIDTH / 2,
                mouseY: 50,
                mouseDown: false,
                activeFruit: null,
                nextSpawnTime: 0
            };
            
            document.getElementById('gameOverScreen').classList.remove('show');
            updateScore();
            drawNextFruitPreview();
        }

        function togglePause() {
            if (gameState.gameOver) return;
            gameState.paused = !gameState.paused;
            document.getElementById('pauseBtn').textContent = gameState.paused ? 'Resume' : 'Pause';
        }

        // Initialize
        document.getElementById('bestScore').textContent = gameState.bestScore;
        drawNextFruitPreview();
        gameLoop();
    </script>
</body>
</html>
